<%@ page language="java" contentType="text/html; charset=US-ASCII" pageEncoding="US-ASCII"%>
<html>
<head>
<link rel="stylesheet" type="text/css" href="../../css/content.css" />
<jsp:include page="../Header_Java.jsp" />
<title>cHAPTER 3 bITWISE oPERATORS</title>
<% session.setAttribute("key","3_5_7");%>
</head>
<div id="menu">
<ul>
  <li><a href="../TechnicalViews.jsp">Technical Views</a></li>
  <li><a href="../funWeDo.html">Fun WE</a></li>
</ul>
</div>
<body>
<script type="text/javascript" src="../../js/script.js"></script>
<table>
<tr>
<td width=20% height=100% valign="top" bgcolor="#eaeaea">
<button class="accordion">a sIMPLE jAVA pROGRAM</button>
<div class="panel">
<p><a href="../chapter3/3_1asimplejavaprogram.jsp">a sIMPLE jAVA pROGRAM</a></p></div>
<button class="accordion">cOMMENTS</button>
<div class="panel">
<p><a href="../chapter3/3_2comments.jsp">cOMMENTS</a></p></div>
<button class="accordion">dATA tYPES</button>
<div class="panel">
<p><a href="../chapter3/3_3datatypes.jsp">dATA tYPES</a></p><p><a href="../chapter3/3_3_1integertypes.jsp">iNTEGER tYPES</a></p>
<p><a href="../chapter3/3_3_2floatingpointtypes.jsp">fLOATINGpOINT tYPES</a></p>
<p><a href="../chapter3/3_3_3thechartype.jsp">tHE CHAR tYPE</a></p>
<p><a href="../chapter3/3_3_4unicodeandthechartype.jsp">uNICODE AND THE CHAR tYPE</a></p>
<p><a href="../chapter3/3_3_5thebooleantype.jsp">tHE BOOLEAN tYPE</a></p>
</div>
<button class="accordion">vARIABLES</button>
<div class="panel">
<p><a href="../chapter3/3_4variables.jsp">vARIABLES</a></p></div>
<button class="accordion">oPERATORS</button>
<div class="panel">
<p><a href="../chapter3/3_5operators.jsp">oPERATORS</a></p><p><a href="../chapter3/3_5_1mathematicalfunctionsandconstants.jsp">mATHEMATICAL fUNCTIONS AND cONSTANTS</a></p>
<p><a href="../chapter3/3_5_2conversionsbetweennumerictypes.jsp">cONVERSIONS BETWEEN nUMERIC tYPES</a></p>
<p><a href="../chapter3/3_5_3casts.jsp">cASTS</a></p>
<p><a href="../chapter3/3_5_4combiningassignmentwithoperators.jsp">cOMBINING aSSIGNMENT WITH oPERATORS</a></p>
<p><a href="../chapter3/3_5_5incrementanddecrementoperators.jsp">iNCREMENT AND dECREMENT oPERATORS</a></p>
<p><a href="../chapter3/3_5_6relationalandbooleanoperators.jsp">rELATIONAL AND BOOLEAN oPERATORS</a></p>
<p><a href="../chapter3/3_5_7bitwiseoperators.jsp">bITWISE oPERATORS</a></p>
<p><a href="../chapter3/3_5_8parenthesesandoperatorhierarchy.jsp">pARENTHESES AND oPERATOR hIERARCHY</a></p>
<p><a href="../chapter3/3_5_9enumeratedtypes.jsp">eNUMERATED tYPES</a></p>
</div>
<button class="accordion">sTRINGS</button>
<div class="panel">
<p><a href="../chapter3/3_6strings.jsp">sTRINGS</a></p><p><a href="../chapter3/3_6_1substrings.jsp">sUBSTRINGS</a></p>
<p><a href="../chapter3/3_6_2concatenation.jsp">cONCATENATION</a></p>
<p><a href="../chapter3/3_6_3stringsareimmutable.jsp">sTRINGS aRE iMMUTABLE</a></p>
<p><a href="../chapter3/3_6_4testingstringsforequality.jsp">tESTING sTRINGS FOR eQUALITY</a></p>
<p><a href="../chapter3/3_6_5emptyandnullstrings.jsp">eMPTY AND nULL sTRINGS</a></p>
<p><a href="../chapter3/3_6_6codepointsandcodeunits.jsp">cODE pOINTS AND cODE uNITS</a></p>
<p><a href="../chapter3/3_6_7thestringapi.jsp">tHE sTRING api</a></p>
<p><a href="../chapter3/3_6_8readingtheonlineapidocumentation.jsp">rEADING THE oNLINE api dOCUMENTATION</a></p>
<p><a href="../chapter3/3_6_9buildingstrings.jsp">bUILDING sTRINGS</a></p>
</div>
<button class="accordion">iNPUT AND oUTPUT</button>
<div class="panel">
<p><a href="../chapter3/3_7inputandoutput.jsp">iNPUT AND oUTPUT</a></p><p><a href="../chapter3/3_7_1readinginput.jsp">rEADING iNPUT</a></p>
<p><a href="../chapter3/3_7_2formattingoutput.jsp">fORMATTING oUTPUT</a></p>
<p><a href="../chapter3/3_7_3fileinputandoutput.jsp">fILE iNPUT AND oUTPUT</a></p>
</div>
<button class="accordion">cONTROL fLOW</button>
<div class="panel">
<p><a href="../chapter3/3_8controlflow.jsp">cONTROL fLOW</a></p><p><a href="../chapter3/3_8_1blockscope.jsp">bLOCK sCOPE</a></p>
<p><a href="../chapter3/3_8_2conditionalstatements.jsp">cONDITIONAL sTATEMENTS</a></p>
<p><a href="../chapter3/3_8_3loops.jsp">lOOPS</a></p>
<p><a href="../chapter3/3_8_4determinateloops.jsp">dETERMINATE lOOPS</a></p>
<p><a href="../chapter3/3_8_5multipleselectionstheswitchstatement.jsp">mULTIPLE sELECTIONStHE SWITCH sTATEMENT</a></p>
<p><a href="../chapter3/3_8_6statementsthatbreakcontrolflow.jsp">sTATEMENTS tHAT bREAK cONTROL fLOW</a></p>
</div>
<button class="accordion">bIG nUMBERS</button>
<div class="panel">
<p><a href="../chapter3/3_9bignumbers.jsp">bIG nUMBERS</a></p></div>
<button class="accordion">aRRAYS</button>
<div class="panel">
<p><a href="../chapter3/3_10arrays.jsp">aRRAYS</a></p><p><a href="../chapter3/3_10_1theforeachloop.jsp">tHE FOR EACH lOOP</a></p>
<p><a href="../chapter3/3_10_2arrayinitializersandanonymousarrays.jsp">aRRAY iNITIALIZERS AND aNONYMOUS aRRAYS</a></p>
<p><a href="../chapter3/3_10_3arraycopying.jsp">aRRAY cOPYING</a></p>
<p><a href="../chapter3/3_10_4commandlineparameters.jsp">cOMMANDlINE pARAMETERS</a></p>
<p><a href="../chapter3/3_10_5arraysorting.jsp">aRRAY sORTING</a></p>
<p><a href="../chapter3/3_10_6multidimensionalarrays.jsp">mULTIDIMENSIONAL aRRAYS</a></p>
<p><a href="../chapter3/3_10_7raggedarrays.jsp">rAGGED aRRAYS</a></p>
</div>

</td>
<td>
<div id="post">
<h3>cHAPTER 3 bITWISE oPERATORS</h3>
<p>When working with any of integer type , you have operators that can work directly with the bits that make up the integers which means you can use masking technique to get at individual bits in a number .</p> 

 

<p> &(and) |(or)  ^(xor) ~ (not) these operator works on bit pattern , If n is a integer variable than </p> 

 

<p>int forthBitFromRight  = (n & 0b1000) / 0b1000;</p> 

 

<p>Give you a one if forth bit from the right in the binary representation of n is 1 and 0 otherwise . Using & with the appropriate power of 2 lets you mask out all but a single bit </p> 

 

<p>There are also >> and << operators which shift a bit pattern to the left or right . These operators are convenient when you need to build a bit pattern</p> 

 

<pre> int fourthBitFromRight = (n & (1 << 3)) >> 3;</pre> 

 

<p>Finally, a >>> operator fills the top bits with zero, unlike >> which extends the sign bit into the top bits. There is no <<< operator.</p> 

<h3>Caution</h3> 

<p>The right-hand argument of the shift operators is reduced modulo 32 (unless the left-hand argument is a long, in which case the right-hand argument is reduced modulo 64). For example, the value of 1 << 35 is the same as 1 << 3 or 8.</p> 

 
<h3>C++ Note</h3> 

<p>In C/C++, there is no guarantee as to whether >> performs an arithmetic shift (extending the sign bit) or a logical shift (filling in with zeroes). Implementors are free to choose whichever is more efficient. That means the C/C++ >> operator may yield implementation-dependent results for negative numbers. Java removes that uncertainty.</p> 

 

<p>A bitwise operator manipulates individual bits of its operands. Bitwise operators are listed in <p> 

 

<img src="img/oper1.jpg" height="50%" width="50%"/><br>  

<p>All bitwise operators work with only integers. The bitwise AND (&) operator operates on corresponding bits of its two operands and returns 1 if both bits are 1, and 0 otherwise. Note that the bitwise AND (&) operates on each bit of the respective operands, not on the operands as a whole. The following is the result of all bit combination using the bitwise AND (&) operator:</p> 

 

<pre> 

1 & 1 = 1 
1 & 0 = 0 
0 & 1 = 0 
0 & 0 = 0 

</pre> 

 

<p>Consider the following piece of code in Java:</p> 

 

<pre>int i = 13 & 3;</pre> 

 

<p>The value of 13 & 3 is computed as follows. The 32 bits have been shown in 8-bit chunks for clarity. In memory, all 32 bits are contiguous</p> 

 

<p>The value of 13 & 3 is computed as follows. The 32 bits have been shown in 8-bit chunks for clarity. In memory, all 32 bits are contiguous.<p> 

<pre> 

13         00000000 00000000 00000000 00001101 
3         00000000 00000000 00000000 00000011 
---------------------------------------------- 
13 & 3 -   00000000 00000000 00000000 00000001 (Equal to decimal 1) 

</pre> 

 

<p>The bitwise OR (|) operates on corresponding bits of its operands and returns 1 if either bit is 1, and 0 otherwise. The following is the result of all bit combinations using bitwise OR (|) operator:</p> 

<pre> 

1 | 1 = 1 
1 | 0 = 1 
0 | 1 = 1 
0 | 0 = 0  

The value of 13 | 3 can be computed as follows. The result of 13 | 3 is 15. 

13       00000000 00000000 00000000 00001101 
3       00000000 00000000 00000000 00000011 
-------------------------------------------- 
13 | 3   00000000 00000000 00000000 00001111 (Equal to decimal 15) 

</pre> 

 

<p>The bitwise XOR (^) operates on corresponding bits of its operands and returns 1 if only one of the bits is 1. 
Otherwise, it returns 0. The following is the result of all bit combinations using bitwise XOR (^) operator:</p> 

<pre> 

1 ^ 1 = 0 
1 ^ 0 = 1 
0 ^ 1 = 1 
0 ^ 0 = 0  

The value of 13 ^ 3 can be computed as follows. The result of 13 ^ 3 is 14. 

13      00000000 00000000 00000000 00001101 
3      00000000 00000000 00000000 00000011 
------------------------------------------- 
13 ^ 3  00000000 00000000 00000000 00001110 (Equal to decimal 14) 

</pre> 

 

<p>The bitwise NOT (~) operates on each bit of its operand. It inverts the bits, that is,
 1 is changed to 0 and 0 is changed to 1. It is also called a bitwise complement operator.
  It computes 1s complement of its operand. The following is the result of all bit combinations using
   bitwise NOT (~) operator:</p> 

<pre> 

~1 = 0 
~0 = 1  

The value of ~13 can be computed as follows. The result of ~13 is -14. 

13     00000000 00000000 00000000 00001101 
------------------------------------------ 
~13    11111111 11111111 11111111 11110010  (Equal to decimal -14) 

</pre> 

 

<p>The bitwise left shift operator (<<) shifts all the bits to the left by the number of bits specified as its right-hand operand. 
It inserts zeros at the lower-order bits. The effect of shifting 1 bit to left is same as multiplying the number by 2. 
Therefore, 9 << 1 will produce 18, whereas 9 << 2 produces 36. The procedure to compute 13 << 4 can be depicted as shown in below </p> 

 

<img src="img/oper2.jpg" height="40%" width="40%"/><br>  

<p>Computing 13 << 4</p> 

<p>What is the result of 13 << 35? You might have guessed zero. However, this is not true. In fact, only 32 bits are used to represent 13, because 13 is considered as int literal and int occupies 32 bits. You can shift all bits to the left only by 31 bits in an int. If the left-hand operand of bitwise left shift operator (<<) is int, only five lower order bits value of the right-hand operand is used as the number of bits to shift. For example, in 13 << 35, the right-hand operand (35) can be represented in binary as follows:</p> 

<pre>00000000000000000000000000100011 </pre> 

<p>The five lower order bits in 35 are 00011, which is equal to 3. Therefore, when you write 13 << 35, it is equivalent to writing 13 << 3. For all positive right-hand operands of the bitwise left shift operator, you can take the modulus of the right-hand operand with 32, which would be the final number of bits to shift. Therefore, 13 << 35 can be considered as 13 << (35 % 32) which is the same as 13 << 3. If the left-hand operand is long, the value of the first six lower order bits of the right-hand operand is used as the number of bits to shift.</p> 

<pre>long  val = 13; 
long result; 
result = val << 35;  

</pre> 

<p>Since val is a long variable, the six lower order bits of 35, which are 100011, will be used as the number to shift. Below shows the steps used to compute 13 >> 4 and -13 >> 4.</p> 

<p>Computing 13 >> 4 and -13 >> 4</p> 

<p>The bitwise signed right shift operator (>>) shifts all the bits to the right by the number specified as its right-hand operand. If the most significant digit of the left-hand operand is 1 (for negative numbers), all higher order bits are filled with 1s after the shift operation. If the most significant bit is 0 (for positive numbers), all higher order bits are filled with 0s. Because the sign bit after right shift operation (>>) remains the same, it is called a signed right shift operator. For example, 13 >> 4 results in zero, as depicted in Figure. Also note that in the case of -13 >> 4 all four higher order bits are filled with 1s because in -13, the most significant digit is 1. The result of -13 >> 4 is -1.</p> 

<p>The unsigned right shift operator (>>>) works the same as the signed right shift operator (>>), except for one difference. It always fills the higher order bits with zero. The result of 13 >>> 4 is zero whereas the result of -13 >>> 4 is 268435455, as shown below. There is no unsigned left shift operator.</p> 

 

<img src="img/oper3.jpg" height="80%" width="80%"/><br>  

<pre> 

13        00000000 00000000 00000000  00001101 
13 >>> 4  00000000 00000000 00000000  00000000 1101 
 
-13        11111111 11111111 11111111  11110011 
-13 >>> 4  00001111 11111111 11111111  11111111 0011  

</pre> 

<p>A compound bitwise assignment operator is used in the following form: 

operand1 op= operand2  

Here, op is one of the bitwise operators of &, |, ^, <<, >>, and >>>. operand1 and operand2 are of primitive integral data type where operand1 must be a variable. The above expression is equivalent to the following expression: 

</p> 

 

<pre>operand1 = (Type of operand1) (operand1 op operand2) </pre> 

<jsp:include page="../status_change.jsp" />
</div>
</td>
</tr>
</table>
<script>
var acc = document.getElementsByClassName("accordion");
var i;

for (i = 0; i < acc.length; i++) {
    acc[i].onclick = function(){
        this.classList.toggle("active");
        var panel = this.nextElementSibling;
        if (panel.style.display === "block") {
            panel.style.display = "none";
        } else {
            panel.style.display = "block";
        }
    }
}
</script>

</body>
<a href="../chapter3/3_5_6relationalandbooleanoperators.jsp"> << Previous</a>
<a href="../TableOfContentJava.jsp"> TOC </a>
<a href="../chapter3/3_5_8parenthesesandoperatorhierarchy.jsp">Next >> </a>
<jsp:include page="../footer.html" />
</html>
